// Lab5.ino

/*
    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
    software and any derivatives exclusively with Microchip products.

    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.

    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.

    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
    TERMS.
*/

#include <LoRa.h>
#include <RTCZero.h>
#include <RN487x_BLE.h>

#define debugSerial SerialUSB
#define loraSerial  Serial2
#define bleSerial Serial1

/* Create an rtc object */
RTCZero rtc;

/* Change these values to set the current initial time */
unsigned int seconds = 0;
unsigned int minutes = 00;
unsigned int hours = 12;

/* Change these values to set the current initial date */
unsigned int day = 20;
unsigned int month = 3;
unsigned int year = 17;

// Variables will contain your personal OTAA Activation Keys
uint8_t devEUI[8] ;   // Device EUI
uint8_t appEUI[8] ;   // App EUI
uint8_t appKey[16] ;  // App Key
const uint8_t appKeyPrefix[8] = {0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88} ;

// Step 5 Replace here the 00â€™s by your appEUI generated by TTN
const uint8_t appEUIfromTTN[8] = { 0x70, 0xB3, 0xD5, 0x7E, 0xF0, 0x00, 0x5E, 0xBE } ;

// Reception buffer
uint8_t frameReceived[255];

void setup()
{
  while (!debugSerial && (millis() < 10000)) ;
  debugSerial.begin(115200) ;
  // Set the optional debug stream
  rn487xBle.setDiag(debugSerial) ;
  debugSerial.println("Microchip Technology ExpLoRer Starter Kit") ;
  debugSerial.println("21080_IoT3 Masters 2017 Class") ;
  debugSerial.println("Lab 5") ;

  // --------------------------------------------------------------------------
  // Init section
  // --------------------------------------------------------------------------
  // Temperature sensor
  pinMode(TEMP_SENSOR, INPUT) ;
  analogReadResolution(12) ;

  // LED
  pinMode(LED_BUILTIN, OUTPUT) ;
  pinMode(LED_RED, OUTPUT) ;
  pinMode(LED_GREEN, OUTPUT) ; 
  pinMode(LED_BLUE, OUTPUT) ;

  // Button
  pinMode(BUTTON, INPUT_PULLUP) ;

  // RTC
  rtc.begin() ; //Start RTC library, this is where the clock source is initialized
  rtc.setTime(hours, minutes, seconds) ; //set time
  rtc.setDate(day, month, year) ;        //set date
  //rtc.setAlarmTime(00, 00, 10); //set alarm time to go off in 10 seconds
  rtc.setAlarmSeconds(10) ;
  // Following two lines enable alarm, comment both out if you want to do external interrupt
  rtc.enableAlarm(rtc.MATCH_SS) ;       //set alarm
  rtc.attachInterrupt(ISR_RTCC) ;       //creates an interrupt that wakes the SAMD21 which is triggered by a FTC alarm
  //comment out the below line if you are using RTC alarm for interrupt
  attachInterrupt(BUTTON, ISR_Button, LOW) ; //creates an interrupt source on external pin

  // LoRa
  LoRa.hwInit() ;
  loraSerial.begin(LoRa.getDefaultBaudRate()) ;
  LoRa.initLoRaStream(loraSerial) ;
  LoRa.swInit() ;
  
  // --------------------------------------------------------------------------
  // Activation keys section
  // --------------------------------------------------------------------------
  // Get the internal Hardware EUI of the LoRaWAN module
  uint8_t hwEUI[8] ;
  uint8_t len = LoRa.getHWEUI(hwEUI, sizeof(hwEUI)) ;
  if (len == 0) { debugSerial.println("Error to get HwEUI") ; while(1) ; }
  
  // Device EUI is the unique identifier for this device on the network
  // Assign the Hardware EUI as the devEUI key
  memcpy(devEUI, hwEUI, sizeof(hwEUI)) ;
  // App EUI is generated by the TTN Application Server
  memcpy(appEUI, appEUIfromTTN, sizeof(appEUIfromTTN)) ;
  // App Key can be a default key for all devices or can be unique per device
  // Here the key is computed by the help of the Device EUI
  // The 16-Bytes format will start by: FF EE DD CC BB AA 99 88 and 
  // will finish by: the 8 Bytes of the devEUI
  memcpy(appKey, appKeyPrefix, sizeof(appKeyPrefix)) ;
  memcpy(appKey + 8, devEUI, sizeof(devEUI)) ;

  // --------------------------------------------------------------------------
  // Display activation keys section
  // --------------------------------------------------------------------------
  debugSerial.println("") ;
  debugSerial.print("devEUI = ") ;
  displayArrayInOneLine(devEUI, sizeof(devEUI)) ;
  debugSerial.print("appEUI = ") ;
  displayArrayInOneLine(appEUI, sizeof(appEUI)) ;
  debugSerial.print("appKey = ") ;
  displayArrayInOneLine(appKey, sizeof(appKey)) ;

  // --------------------------------------------------------------------------
  // Network Activation section
  // --------------------------------------------------------------------------
  bool joinRes = 0 ;
  uint8_t joinTentative = 0 ;
  do
  {
    setRgbColor(0x00, 0x00, 0xFF) ;
    debugSerial.println("Try to join the LoRa network through OTA Activation") ;
    joinRes = LoRa.joinOTAALoRaNetwork(1, devEUI, appEUI, appKey, true, 3) ;
    debugSerial.println(joinRes ? "Join Accepted." : "Join Failed! Trying again after 3 seconds.") ;
    if (!joinRes)
    {
      setRgbColor(0xFF, 0x00, 0x00) ;
      joinTentative ++ ;
      delay(3000) ;
    }
    if (joinTentative == 3)
    {
      debugSerial.println("Not able to join the network. Stay here forever!") ;
      while(1)
      {
        setRgbColor(0xFF, 0x00, 0x00) ;
        delay(250) ;
        setRgbColor(0x00, 0x99, 0xFF) ;
        delay(250) ;
        setRgbColor(0xFF, 0xFF, 0xFF) ;
        delay(250) ;
      }
    }
  } while (joinRes == 0) ;
  setRgbColor(0x00, 0xFF, 0x00) ;
  delay(3000) ;
  debugSerial.println("Push the button to send a message over the LoRa Network ...") ;
}

unsigned int r, g, b;
uint8_t Done = false;
bool isISR_RTCC, isLoRaSleep, isISR_Button, isTimeSet = false;

void loop()
{
  if (!isLoRaSleep)
  {
    LoRa.sleep();
    isLoRaSleep = true;
    //delay(1000);
    if (!debugSerial)
    { // If USB debug is connected,  do NOT go in SLEEP, just wait for isISR_RTCC
      rn487xBle.hwSleep();
      samSleep();
      while (!getButton());// if woke up because of button,  wait until release
    }
  }
  if (isISR_RTCC || isISR_Button)
  {
    isISR_RTCC = false;
    isLoRaSleep = false;
    LoRa.wakeUp();

    debugSerial.println("Awake");
    delay(1000);
    // Flush receive buffer
    uint8_t ms_cur = 0;
    do
    {
      if (loraSerial.available() > 0)
      {
        uint8_t incomingByte = loraSerial.read();
        debugSerial.write(incomingByte);
      }
      ++ms_cur;
      delay(1);
    } while (ms_cur < 100) ;

    debugSerial.println("Awake");

  }
  else
  { 
    // Only reach here when in DEBUG mode with Terminal connected to the board
    debugSerial.print(".");
    delay(1000);
    return;
  }
  bool pushButton = false;
  char load[50];
  char load1[50];
  if (isISR_Button == true)
  {
    isISR_Button = false;
    LoRa.setDataRate(3);
    sprintf(load, "Temp=%.2f degree C at %d:%02d", getTemperature(), rtc.getHours(), rtc.getMinutes());
  }
  else
  {
    //sprintf(load, "Temp=%.2f at %02d:%02d", getTemperature(), rtc.getHours(), rtc.getMinutes());
    sprintf(load, "Temp=%.2f", getTemperature());
  }

  if (1)
  {
    // Button has been pressed
    turnBlueLedOn();
    pushButton = true;
    while (getButton() == LOW);
    // Button has been released
    turnBlueLedOff();
    pushButton = false;
    debugSerial.println("Try to transmit an uplink message ...");
    turnBlueLedOn();
    delay(100);
    turnBlueLedOff();
    setRgbColor(r, g, b);

    switch (LoRa.sendReqAck(2, (const uint8_t*)load, strlen (load), 3))
    {
      case NoError:
        Done = true;
        debugSerial.println("Successful transmission.");
        digitalWrite(LED_BUILTIN, LOW);
        //setRgbColor(0x00, 0xFF, 0x00);
        break;
      case NoResponse:
        debugSerial.println("There was no response from the device.");
        setRgbColor(0xFF, 0x00, 0x00);
        break;
      case Timeout:
        debugSerial.println("Connection timed-out. Check your serial connection to the device! Sleeping for 20sec.");
        setRgbColor(0xFF, 0x00, 0x00);
        break;
      case PayloadSizeError:
        debugSerial.println("The size of the payload is greater than allowed. Transmission failed!");
        setRgbColor(0xFF, 0x00, 0x00);
        break;
      case InternalError:
        debugSerial.println("Oh No! This shouldn't happen. Something is really wrong! Try restarting the device!\r\nThe program will now halt.");
        setRgbColor(0xFF, 0x00, 0x00);
        while (1) {
        };
        break;
      case Busy:
        debugSerial.println("The device is busy. Sleeping for 10 extra seconds.");
        delay(10000);
        break;
      case NetworkFatalError:
        debugSerial.println("There is a non-recoverable error with the network connection. You should re-connect.\r\nThe program will now halt.");
        setRgbColor(0xFF, 0x00, 0x00);
        while (1) {
        };
        break;
      case NotConnected:
        debugSerial.println("The device is not connected to the network. Please connect to the network before attempting to send data.\r\nThe program will now halt.");
        setRgbColor(0xFF, 0x00, 0x00);
        while (1) {
        };
        break;
      case NoAcknowledgment:
        debugSerial.println("There was no acknowledgment sent back!");
        setRgbColor(0xFF, 0x00, 0x00);
        break;
      default:
        break;
    }

    // Downlink
    int frameReceivedSize = LoRa.receive(frameReceived, sizeof (frameReceived));
    if (frameReceivedSize > 0)
    {
      debugSerial.print("Downlink received : ");

      debugSerial.print((char *) frameReceived);
      if (strstr((const char*) frameReceived, "Color")) {
        sscanf((const char*) frameReceived, "%s %d %d %d", load, &r, &g, &b);
        //sprintf(load1, "%s %d %d %d", load, &r, &g, &b);
        //debugSerial.print((char *) load1);
        setRgbColor(r, g, b);
      }
      debugSerial.print(" ");
      debugSerial.println("");
    }
    if (Done)
    {
      Done = false;
      //debugSerial.println("Sleep for 60 seconds");
      debugSerial.println("Push the button to send a message over the LoRa Network ...");
    }
  }
}

// --------------------------------------------------------------------------
// Display array in HEX format routine
// --------------------------------------------------------------------------
void displayArrayInOneLine(const uint8_t tab[], uint8_t tabSize)
{
  char c[2] ;
  for (uint8_t i = 0; i < tabSize; i++)
  {
    sprintf(c, "%02X", tab[i]) ;
    debugSerial.print(c) ;
  }
  debugSerial.println("") ;
}

// --------------------------------------------------------------------------
// TEMPERATURE routine
// --------------------------------------------------------------------------
float getTemperature()
{
  int sensorValue = analogRead(TEMP_SENSOR) ;
  float mVolts = (float)sensorValue * 3300 / 4096.0 ;
  float temp = (mVolts - 500) ;
  temp = temp / 10.0 ;
  return (temp) ;
}

// --------------------------------------------------------------------------
// LED routines
// --------------------------------------------------------------------------
#define COMMON_ANODE  // LED driving
void setRgbColor(uint8_t red, uint8_t green, uint8_t blue)
{
#ifdef COMMON_ANODE
  red = 255 - red;
  green = 255 - green;
  blue = 255 - blue;
#endif
  analogWrite(LED_RED, red);
  analogWrite(LED_GREEN, green);
  analogWrite(LED_BLUE, blue);
}

void turnBlueLedOn()
{
  digitalWrite(LED_BUILTIN, HIGH);
}

void turnBlueLedOff()
{
  digitalWrite(LED_BUILTIN, LOW);
}

// --------------------------------------------------------------------------
// PUSH BUTTON routine
// --------------------------------------------------------------------------
bool getButton()
{
  return digitalRead(BUTTON) ;
}

// --------------------------------------------------------------------------
// INTERRUPT routines
// --------------------------------------------------------------------------
// Interrupt service routine (ISR_RTCC), called when interrupt is triggered
// Executes after MCU wakes up
bool ledstate = true;
void ISR_RTCC()
{
  uint8_t Buffer[100];

  sprintf (( char*)Buffer, "Time %02d:%02d:%02d", rtc.getHours(), rtc.getMinutes(), rtc.getSeconds());
  debugSerial.println((char *)Buffer);
  debugSerial.println("ISR_RTCC");
  digitalWrite(LED_BUILTIN, ledstate ? HIGH : LOW);
  ledstate ^= 1;
  isISR_RTCC = true;
}

void ISR_Button()
{
  isISR_Button = true;
  debugSerial.println("Button interrupt\r\n");
}

// --------------------------------------------------------------------------
// LOW POWER MODES routines
// --------------------------------------------------------------------------
void samSleep()
{
  // Set the sleep mode to standby
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
  EIC->WAKEUP.reg |= EIC_INTENSET_EXTINT(1 << 14);
  // SAMD sleep
  __WFI();
}

